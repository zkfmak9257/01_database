-- Q1
SELECT
    EMP_NAME,
    CONCAT(SUBSTR(phone, 1, 3), '-', SUBSTR(phone, 4, 4), '-', SUBSTR(phone, 8, 4)) AS PHONE
FROM EMPLOYEE;

-- Q2
SELECT
    EMP_NAME 직원명,
    DATE_FORMAT(HIRE_DATE, '%Y년%c월%e일') AS 입사일,
    FORMAT(TRUNCATE(SALARY, 0), 0) AS 급여
FROM EMPLOYEE
-- WHERE DATEDIFF(CURDATE(),HIRE_DATE) > 20*365
WHERE HIRE_DATE <= SUBDATE(CURDATE(), INTERVAL 20 YEAR)
ORDER BY 입사일, SALARY DESC;
/*
1) 정확도(윤년/달력 기반)
DATEDIFF(CURDATE(), HIRE_DATE) > 20*365
20년을 7300일로 고정 가정합니다. 윤년(2/29) 4~5일을 무시하므로 실제 캘린더 20년과 어긋날 수 있습니다.
예) 20년 사이에 윤년이 5번 끼면, 실제 20년 = 7305일 → 20년이 아직 안 지났는데도 조건을 통과하거나(혹은 반대) 하는 오프바이일이 발생 가능.
HIRE_DATE <= SUBDATE(CURDATE(), INTERVAL 20 YEAR)
달력 연-월-일 연산으로 정확히 “오늘로부터 20년 전 날짜”를 계산합니다.
윤년/말일 보정도 MySQL/MariaDB가 처리(유효하지 않은 날짜는 그 달의 말일로 보정)하므로 캘린더 기준으로 정확합니다.
결론: 캘린더 기준 “정확히 20년”을 원하면 INTERVAL 20 YEAR가 맞습니다.
*/

-- Q3
SELECT T.EMP_NAME, FORMAT(TRUNCATE(T.SALARY, 0), 0), CONCAT(ROUND(T.BONUS*100),'%'), FORMAT(TRUNCATE(T.TOTAL_SALARY, 0), 0)
FROM (
SELECT EMP_NAME, SALARY, BONUS, SALARY*2 AS TOTAL_SALARY
FROM EMPLOYEE
WHERE BONUS IS NULL
UNION
SELECT EMP_NAME, SALARY, BONUS, SALARY + SALARY*BONUS AS TOTAL_SALARY
FROM EMPLOYEE
WHERE BONUS IS NOT NULL
) AS T
ORDER BY T.TOTAL_SALARY DESC;


-- Q4
SELECT EMP_NAME, LPAD(EMAIL, (SELECT MAX(LENGTH(EMAIL)) FROM EMPLOYEE), ' ')
FROM EMPLOYEE;

-- Q5
SELECT
    CONCAT(E.EMP_NAME, ' ', J.JOB_NAME, '님') AS NAME_TAG,
    CONCAT(SUBSTR(E.EMP_NO, 1, 8), RPAD('',6,'*')) AS EMP_NO,
    CONCAT(N.NATIONAL_NAME, '지사 ', D.DEPT_TITLE, ' 소속') AS BELONG,
    IF(E.MANAGER_ID = M.EMP_ID, M.EMP_NAME, NULL) AS MANAGER_NAME
FROM EMPLOYEE E
JOIN DEPARTMENT D ON E.DEPT_CODE = D.DEPT_ID
JOIN JOB J ON E.JOB_CODE = J.JOB_CODE
JOIN LOCATION L ON D.LOCATION_ID = L.LOCAL_CODE
JOIN NATIONAL N ON L.NATIONAL_CODE = N.NATIONAL_CODE
LEFT OUTER JOIN EMPLOYEE M ON E.MANAGER_ID = M.EMP_ID
ORDER BY MANAGER_NAME;